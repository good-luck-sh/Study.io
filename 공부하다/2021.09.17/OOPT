클래스 

Static메소드, Static변수를 제외하고  객체를 생성할 때 사용되는 설계도 이다.
구성요소는 변수, 생성자, 메소드이다. 
객체 

클래스의 구성요건들을 객체로 만들고 실제로 사용가능한 상태로 만드는 것을 의미한다. 
클래스는 설계도를 이용해서 메모리의 힙영역에 생성된다. 
객체는 고유한 주소값을 가지고 있다. 
객체의 주소값을 (Reference)라고 한다. 
객체의 참조값은 참조변수에 저장한다. 
참조변수 

객체의 참조값을 저장하는 변수다. 
참조변수의 타입은 객체 생성에 사용된 클래스가 타입이다. 
클래스로 만들어진 객체기 때문에 객체 생성에 사용된 클래스이기 때문에 객체 생성에 사용된 클래스가 타입이다.
클래스타입

Person person = new Person();
Person은 참조변수의 타입이다. 
Person은 참조변수이다. 
객체의 멤버변수, 멤버메소드의 사용은 항상 참조 변수를 통해서만 사용이 가능하다. 
PersonService service = new PersonService (); // 참조변수를 우선 생성하고
service.printAllPerson();   --->참조변수 dot 메소드로 사용을 한다. 
참조변수의 값이 null이면, 참조변수는 객체를 참조하고 있는 상태가 아니다. 
null값을 가지고 있는 참조변수의 멤버변수와 멤버메소드를 사용하게 되면 nullpointerException의 오류가 발생한다. 
멤버변수 

객체의 속성 (정보, 값, 데이터)를 저장하는 변수다. 값을 저장한다. ValueDate라고 불리기도 한다. 
객체가 생성될 때 변수의 타입에 맞는 저장소가 생성이되고, 저장소에는 해당타입의 기본값이 저장되어 있다. 특히, 기본형의 경우에는 기본값이 저장되어 있고, 일반 객체의 경우 null이 입력이 되어있다. 
null이 입력이 되어있는 경우 , 객체의 경우 기본 값은 주소가 입력이 되어있던지, 입력되기전 아무것도 등록되어있지 않다는 의미로 null값이 입력이 되어있는 것이다. 사용하려는 객체의 참조 주소값이 입력이 되면 바로 그 객체의 주소값이 입력이 된다. 
객체가 유지되는 동안 멤버변수에 저장된 값도 계속 유지된다.
멤버메소드

객체의 고유한 기능을 담당한다. 
멤버메소드는 객체내의 모든 멤버변수를 사용할 수 있고, 객체내의 다른 멤버메소드를 실행 할 수 있다. 
멤버메소드의 중복정의가 가능하다. 
생성자 메소드는 멤버메소드가 아니다. 
생성자 메소드 

클래스의 이름과 같은 이름을 가진 메소드이다. 
반환타입에 대한 정의가 없다 (void까지 존재하지 않는다. )
new연산자와 같이 사용된다. 그외의 용도로는 사용할 수 없다. 
new연산자 다음에 (__)으로 사용이 가능하다. 
new연산자로 생성자 메소드의 이름에 해당하는 클래스(같은 이름으로 작성하기 때문)로 객체를 생성한다
객체가 생성되면 new연산자와 같이 사용된 생성자 메소드가 자동으로 실행된다. 
생성자 메소드는 중복정의가 가능하다. 멤버메소드 또한 제공한다. 
생성자 메소드가 중복정의 되어있다는 것은 객체 생성 후 다양한 방법으로 객체를 초기화 할 수 있다는 것다.
class Person{
person(String name, String tel, int age){
this.name = name;
this.tel = tel;
this.age = age;
}}  //이렇게 멤버변수를 이용하여 초기화를 할 수 있다. 
메소드 중복정의(method OverLoding)

하나의 클래스안에서 같은 이름의 메소드를 여러개 정의하는 것을 의미한다. 
중복정의하기 위해서는 매개변수의 갯수, 타입, 타입별 순서가 달라야한다. 
접근제한자, 반환타입은 상관이 없다. 
기능은 비슷한 데, 메소드를 실행할 때 필요한 값이 다르거나 값의 갯수가 다른 경우 중복정의 할 수 있다. 
비슷한 기능은 같은이름으로 실행 할 수 있도록 한다. 
상속

부모클래스의 속성과 기능을 물려받는 것이다. 
부모클래스의 속성과 기능중에서 접근제한자가 Private인 것과 생성자는 자식클래스로 상속되지 않는다. 
상속하는 이유 
여러하위 클래스에 동일한 속성과 동일한 기능이 반복될 때 
부모클래스의 속성과 기능을 물려받아서 빠르게 자식 클래스로 구현해야할 떄 
여러관련있는 여러 클래스들을 같은 종유로 만들어야 할 때
메소드 재정의 

부모로부터 물려받은 메소드를 자식클래스에서 다시 정의하는 것이다. 
접근제한자, 반환타입, 메소드명, 매개변수의 타입 및 갯수가 전부 동일해야한다. 
메소드를 재정의 하는 이유 
부모로부터 물려받은 기능이 자식 클래스에서 사용하기 적합하지 않을 때 
부모클래스와 같은 사용법으로 기능을 구현해야할 때 
Person. print(); Student.print(); 동일한 사용방법으로 이용하고 싶다. 
클래스 형변환

자식타입의 객체를 클래스 타입의 참조변수가 참조하는 것이다. 
자식클래스 타입의 참조변수는 절대 부모클래스타입의 객체를 참조할 수 없다. 
자동 클래스 형변환은 언제나 참조변수와 일치하는 타입의 객체를 생성된 객체에서 검색해서 참조하고 있는 것이다. (super로 조상타입의 객체의 주소값을 참조하고 있는것이다.)
Object타입의 참조 변수는 모든 객체를 참조할 수 있다. 
클래스 형변환이 발생하면 부모타입의 참조변수에 저장된 값은 자식클래스타입의 참조값이 아니라 참조변수의 타입과 일치하는 객체의 주소값이다. 
Phone p = new Iphone(); 
참조변수 p에 저장된 참조값은 Iphone객체의 참조값이 아니라, Iphone 객체 생성시 같이 생성된 Iphone객체의 참조값이다. 
참조변수 p는 Phone객체의 공개된 속성과 기능을 사용할 수 있다.
참조변수 P는 Iphone객체의 속성과 기능을 사용할 수 없다.
Iphone객체와 Phone객체의 메소드 재정의 단계에 있는 메소드가 있으면 Iphone객체의 메소드가 실행된다. 없으면 실행되지 않는다. 
다형성

메소드 중복정의의 다형성
하나의 객체안에 메소드가 매개변수에 메소드가 중복정의 되어 있으면 적절한 메소드가 자동으로 선택되어 실행됩니다. 
메소드 재정의의 다형성
부모클래스 타입의 참조변수가 자식클래스 타입의 객체를 참조하고 있고, 부모클래스와 자식클래스에 메소드 재정의 관계에 있는 메소드가 있을 때 부모클래스 타입으이 참조변수로 재정의 관계에 이쓴ㄴ 메소드를 실행하면 실행 생성된 자식 객체의 재정의된 메소드가 실행된다. 
즉, 실행방법은 동일한 방법으로 계속 실행되는데, 참조하는 자식객체가 달라지면 실행결과가 다르게 발행되는 것이다. 
OOPT

전부 모든 객체지향언어프로그래밍에서 가지고 있는 공통속성과 기능이다. 
구체화가 가능해야 연결이 가능할 수 있다.
